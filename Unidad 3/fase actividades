# Seguimiento del mouse con openFrameworks

Este repositorio contiene un ejemplo b√°sico de una aplicaci√≥n hecha con **openFrameworks**, donde se dibuja un c√≠rculo que sigue al puntero del mouse.

## üìÑ Descripci√≥n

El programa utiliza las funciones b√°sicas de `ofApp` para crear una ventana con fondo negro, y dibujar un c√≠rculo blanco que se actualiza constantemente en la posici√≥n actual del mouse.

### Caracter√≠sticas principales:

- Fondo negro.
- C√≠rculo blanco que sigue la posici√≥n del mouse.
- Redibujo constante en cada `frame`.

## üß† ¬øC√≥mo funciona?

A continuaci√≥n se explica cada parte del c√≥digo:

```cpp
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup(){
    ofBackground(0); // Se establece el color de fondo en negro
}

//--------------------------------------------------------------
void ofApp::update(){
    // No se realiza ninguna actualizaci√≥n de l√≥gica aqu√≠
}

//--------------------------------------------------------------
void ofApp::draw(){
    ofSetColor(255); // Se establece el color blanco
    ofDrawCircle(ofGetMouseX(), ofGetMouseY(), 20); // Dibuja un c√≠rculo en la posici√≥n actual del mouse
}
```

# üé® Actividad 2 - Part√≠culas Interactivas con openFrameworks

Esta actividad es una introducci√≥n pr√°ctica al ciclo b√°sico de una aplicaci√≥n hecha en **openFrameworks**. A trav√©s de este ejercicio, se implementa una peque√±a animaci√≥n interactiva que responde al movimiento y clics del mouse, generando part√≠culas visuales en la pantalla.

---

## üìã Contexto del ejercicio

La aplicaci√≥n dibuja part√≠culas (c√≠rculos) en las posiciones donde se mueve el mouse. Estas part√≠culas se almacenan en un vector y se actualizan din√°micamente, de modo que se eliminan las m√°s antiguas para evitar que se acumulen infinitamente. Adem√°s, al hacer clic, el color de todas las part√≠culas cambia aleatoriamente.

---

## ‚ùì An√°lisis del c√≥digo

### üîπ ¬øQu√© fue lo que incluimos en el archivo `.h`?

Se incluyeron las funciones principales del ciclo de vida (`setup`, `update`, `draw`) y dos funciones que responden a eventos del mouse (`mouseMoved`, `mousePressed`). Tambi√©n se declararon dos variables privadas:

- `particles`: un vector de `ofVec2f`, que almacena las posiciones del mouse para dibujar las part√≠culas.
- `particleColor`: una variable `ofColor` que define el color actual que tendr√°n las part√≠culas.

---

## ‚öôÔ∏è Explicaci√≥n general de las funciones

### `setup()`

**En openFrameworks**:  
Se ejecuta una sola vez al inicio de la aplicaci√≥n. Sirve para inicializar variables, configurar el fondo, cargar recursos, etc.

**En este ejercicio**:  
Se usa para establecer el fondo en color negro (`ofBackground(0)`) y definir el color blanco como valor inicial para las part√≠culas.

---

### `update()`

**En openFrameworks**:  
Se llama una vez por frame. Sirve para actualizar la l√≥gica del programa, como animaciones, c√°lculos, f√≠sicas, etc.

**En este ejercicio**:  
No contiene l√≥gica espec√≠fica, pero est√° presente por convenci√≥n, listo para posibles mejoras futuras.

---

### `draw()`

**En openFrameworks**:  
Dibuja los elementos gr√°ficos en pantalla. Todo lo que se quiera visualizar (formas, im√°genes, texto, etc.) se define aqu√≠.

**En este ejercicio**:  
Se recorre el vector `particles` y se dibuja un c√≠rculo de radio 50 en cada posici√≥n usando el color actual.

---

### `mouseMoved(int x, int y)`

**En openFrameworks**:  
Se ejecuta cada vez que el mouse se mueve dentro de la ventana de la aplicaci√≥n. Recibe las coordenadas actuales.

**En este ejercicio**:  
Cada movimiento del mouse agrega su posici√≥n al vector `particles`. Si el n√∫mero de part√≠culas excede 100, se elimina la m√°s antigua.

---

### `mousePressed(int x, int y, int button)`

**En openFrameworks**:  
Se ejecuta cada vez que el usuario presiona un bot√≥n del mouse. Se puede usar para interacciones con clics.

**En este ejercicio**:  
Cambia el color de las part√≠culas generando un nuevo color aleatorio.

---

## ‚úÖ Resultado esperado

- Se abre una ventana con fondo negro.
- Cada vez que el mouse se mueve, se dibujan c√≠rculos en su trayectoria.
- El color de los c√≠rculos cambia aleatoriamente cada vez que se hace clic.

Esta aplicaci√≥n es √∫til como primer acercamiento a la programaci√≥n interactiva con openFrameworks, manejo de vectores y dibujo b√°sico en pantalla.

---
## Actividad 3
### üîß Experimento: Cambiar C√≠rculos por Cuadrados

Para modificar el c√≥digo y que en lugar de c√≠rculos se dibujen cuadrados, hice el siguiente cambio en el archivo `ofApp.cpp`:

### Modificaci√≥n en el archivo `ofApp.cpp`

Busqu√© esta l√≠nea en la funci√≥n `draw()`:

```cpp
ofDrawCircle(pos.x, pos.y, 50);
```
Y la cambi√© por:

```cpp

ofDrawRectangle(pos.x - 25, pos.y - 25, 50, 50);
```
### ¬øPor qu√© este cambio?
ofDrawCircle(pos.x, pos.y, 50) dibuja un c√≠rculo de radio 50 en las coordenadas (pos.x, pos.y).

ofDrawRectangle(pos.x - 25, pos.y - 25, 50, 50) dibuja un cuadrado con un tama√±o de 50x50. El -25 es para centrar el cuadrado en las mismas coordenadas que antes estaba el c√≠rculo (porque ofDrawRectangle dibuja el rect√°ngulo desde la esquina superior izquierda).

Con este cambio, en lugar de c√≠rculos, la aplicaci√≥n dibujar√° cuadrados cada vez que el mouse se mueva.
# Actividad 5

En esta actividad, se profundiza en el concepto de punteros de manera pr√°ctica. El ejercicio que realizamos permite seleccionar una esfera y moverla con el mouse. El puntero es un concepto clave para modificar objetos de manera eficiente en la memoria.

## Respuestas a las preguntas

### ¬øCu√°l es la definici√≥n de un puntero?
Un puntero es una variable que almacena la direcci√≥n de memoria de otra variable. En lugar de almacenar el valor directamente, almacena la ubicaci√≥n en la memoria donde se encuentra dicho valor. Esto permite acceder y manipular la variable de manera indirecta a trav√©s de su direcci√≥n en memoria.

### ¬øD√≥nde est√° el puntero?
El puntero est√° en la clase `ofApp`, en la variable `selectedSphere`, que es un puntero a un objeto de tipo `Sphere`:

```cpp
Sphere* selectedSphere;
```
### ¬øC√≥mo se inicializa el puntero?
El puntero selectedSphere se inicializa en el m√©todo setup() como nullptr, lo que significa que al inicio no est√° apuntando a ninguna esfera.
```cpp


selectedSphere = nullptr;
```
De esta manera, indicamos que no hay ninguna esfera seleccionada cuando se inicia el programa.

### ¬øPara qu√© se est√° usando el puntero?
El puntero selectedSphere se usa para mantener la referencia de la esfera que el usuario selecciona al hacer clic sobre ella. Una vez seleccionada, el puntero se actualiza para apuntar a esa esfera espec√≠fica. Luego, en el m√©todo update(), el puntero permite mover esa esfera seleccionada a la nueva posici√≥n del mouse.

### ¬øQu√© es exactamente lo que est√° almacenado en el puntero?
El puntero selectedSphere almacena la direcci√≥n de memoria de un objeto de tipo Sphere. Cuando el usuario hace clic en una esfera, el puntero se actualiza para apuntar al objeto Sphere correspondiente en el vector spheres.

### Actividad 6
El c√≥digo presentado tiene un problema relacionado con la selecci√≥n de la esfera. El problema es que no se est√° actualizando correctamente el puntero selectedSphere cuando el mouse es movido. Esto significa que aunque puedes seleccionar una esfera con el click, no puedes seguir movi√©ndola si la dejas presionada y mueves el mouse.

### Problema:
El c√≥digo solo mueve la esfera en el m√©todo update() si el puntero selectedSphere no es nullptr, pero este puntero solo se actualiza al hacer clic en una esfera (en mousePressed). Esto significa que si se mueve el mouse despu√©s de hacer clic en una esfera, no se actualiza su posici√≥n constantemente, ya que mouseMoved no tiene ning√∫n efecto en el c√≥digo.

### Soluci√≥n:
El problema se soluciona al hacer que la esfera seleccionada tambi√©n se mueva mientras el mouse se mueve. Esto se logra de manera sencilla implementando la l√≥gica en el m√©todo mouseMoved(), de modo que el puntero selectedSphere siga la posici√≥n del mouse incluso si no se est√° haciendo clic continuamente.

C√≥digo corregido:
``` cpp
//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y ) {
    // Si hay una esfera seleccionada, se actualiza su posici√≥n
    if (selectedSphere != nullptr) {
        selectedSphere->update(x, y);
    }
}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){
    if(button == OF_MOUSE_BUTTON_LEFT){
        for (auto sphere : spheres) {
            float distance = ofDist(x, y, sphere->getX(), sphere->getY());
            if (distance < sphere->getRadius()) {
                selectedSphere = sphere;
                break;
            }
        }
    }
}
```
## Actividad 7
### 1. ¬øQu√© sucede cuando presionas la tecla ‚Äúc‚Äù?

Cuando presionas la tecla "c", el programa intenta crear un objeto Sphere y lo almacena en el vector globalVector. Sin embargo, al crear el objeto en el stack (en la versi√≥n original), el objeto localSphere se destruye inmediatamente despu√©s de salir del √°mbito de la funci√≥n createObjectInStack. Esto causa que el puntero en el vector apunte a una direcci√≥n de memoria inv√°lida. Por lo tanto, al intentar acceder a este objeto en el vector para dibujarlo, se est√° accediendo a memoria no v√°lida.

### 2. ¬øPor qu√© ocurre esto?

Esto ocurre porque cuando un objeto se crea en el stack, su memoria se gestiona de forma autom√°tica. Esto significa que cuando la funci√≥n createObjectInStack termina, el objeto localSphere es destruido y su memoria es liberada, pero el puntero en globalVector sigue apuntando a una direcci√≥n de memoria que ya no es v√°lida.

Por otro lado, al crear el objeto en el heap usando new, la memoria del objeto se asigna din√°micamente, lo que significa que el objeto permanece en memoria incluso despu√©s de que la funci√≥n termine su ejecuci√≥n. Esto evita que el puntero en globalVector apunte a una direcci√≥n de memoria no v√°lida.

Modificaci√≥n de la funci√≥n createObjectInStack

```cpp


void ofApp::createObjectInStack() {
    // Crear objeto en el heap usando 'new'
    Sphere* heapSphere = new Sphere(ofRandomWidth(), ofRandomHeight(), 30);
    globalVector.push_back(heapSphere);
    ofLog() << "Object created in heap: Position (" << heapSphere->x << ", " << heapSphere->y << ")";
    heapSphere->draw();
}
```
Explicaci√≥n de la correcci√≥n
La funci√≥n ahora crea el objeto Sphere din√°micamente en el heap en lugar de en el stack. Esto resuelve el problema de la destrucci√≥n del objeto cuando sale del √°mbito de la funci√≥n. El puntero heapSphere se agrega al globalVector, y como el objeto ahora persiste en memoria, se puede acceder a √©l posteriormente para dibujarlo.

Conclusi√≥n
El problema en el c√≥digo original es que los objetos se estaban creando en el stack, lo que causaba que los punteros en globalVector apuntasen a memoria que se liberaba al salir de la funci√≥n. Al crear los objetos en el heap, los punteros permanecen v√°lidos, lo que soluciona el problema y permite que los objetos se dibujen correctamente.

### Actividad 8

## 1. Crear objetos en el `heap`

Los objetos deben crearse en el `heap` cuando necesitan **persistir m√°s all√° del contexto de la funci√≥n** en la que fueron creados.

> El `stack` solo mantiene los objetos mientras la funci√≥n en la que fueron creados est√© en ejecuci√≥n. Una vez que la funci√≥n termina, los objetos se destruyen autom√°ticamente. Para evitar esto, se utiliza el `heap` con `new`. Los objetos creados en el `heap` no se destruyen autom√°ticamente: hay que liberar su memoria con `delete`.

### Cu√°ndo usar `new` en el `heap`

- Cuando el objeto debe vivir durante toda la ejecuci√≥n del programa (o hasta que lo elimines manualmente).
- Si no sabes cu√°nto tiempo vas a necesitar el objeto.
- Si quieres que el objeto sea accesible fuera del alcance de la funci√≥n que lo crea.

### Ejemplos de uso del `heap`

- Almacenar objetos en un contenedor como un `std::vector`, donde deben sobrevivir varias iteraciones.
- Cuando la cantidad de objetos es **variable** y no puedes predecir su tama√±o con anticipaci√≥n.

---

## 2. Crear objetos en `memoria global`

Los objetos deben crearse en la memoria global cuando necesitas que sean **accesibles desde cualquier parte del programa** durante toda la ejecuci√≥n.

> Un objeto en memoria global existe durante toda la vida del programa. Puede ser √∫til para compartir estados o configuraciones sin pasarlos constantemente entre funciones.

### Cu√°ndo usar `memoria global`

- Cuando el objeto debe ser accesible desde cualquier parte del c√≥digo.
- Cuando necesitas que el objeto tenga un estado compartido por toda la aplicaci√≥n.

### Ejemplos de uso de `memoria global`

- Un objeto de configuraci√≥n general de la aplicaci√≥n (gr√°ficos, sonido, etc.).
- Un controlador de entrada o sistema de eventos que debe estar disponible en todo momento.

---

## 3. Crear objetos en el `stack`

Los objetos deben crearse en el `stack` cuando solo necesitas que existan **durante la ejecuci√≥n de una funci√≥n**.

> Los objetos en el `stack` son muy eficientes y se destruyen autom√°ticamente al salir del √°mbito donde fueron declarados.

### Cu√°ndo usar el `stack`

- Cuando el objeto solo se necesita dentro de una funci√≥n.
- Cuando no necesitas que el objeto persista o se comparta entre distintas funciones.

### Ejemplos de uso del `stack`

- Variables temporales dentro de funciones, como auxiliares de c√°lculo.
- Objetos de uso inmediato sin necesidad de persistencia o compartici√≥n.

---

## Recomendaciones generales

- Usa el `stack` por defecto cuando sea posible, ya que es m√°s eficiente.
- Usa el `heap` si necesitas control total sobre el ciclo de vida del objeto.
- Usa memoria global con moderaci√≥n, ya que puede dificultar el mantenimiento del c√≥digo.

# Actividad 9 ‚Äì Manejo de Memoria en C++

## Objetivo
Analizar el comportamiento del programa al manipular objetos almacenados din√°micamente en el heap y eliminarlos correctamente.

---

## C√≥digo analizado

### Archivo `ofApp.h`
```cpp
#pragma once

#include "ofMain.h"

class ofApp : public ofBaseApp{
public:
    void setup();
    void update();
    void draw();

    void keyPressed(int key);
    void mousePressed(int x, int y, int button);

private:
    vector<ofVec2f*> heapObjects;
};
```
### ¬øQu√© sucede cuando presionas la tecla ‚Äúf‚Äù?
Cuando se presiona la tecla 'f', se ejecuta el siguiente bloque de c√≥digo:

```cpp

if(!heapObjects.empty()) {
    delete heapObjects.back();   // Libera la memoria del √∫ltimo objeto del heap
    heapObjects.pop_back();      // Elimina el puntero del vector
}
Esto hace dos cosas importantes:

delete heapObjects.back();
Libera de la memoria heap el √∫ltimo objeto (ofVec2f*) que fue creado con new. Esto evita una fuga de memoria (memory leak).

heapObjects.pop_back();
Elimina el puntero del vector heapObjects, asegurando que ya no se acceda a un puntero inv√°lido.
```
### An√°lisis detallado
Este bloque es una forma segura de eliminar objetos del heap:

Primero se verifica si el vector no est√° vac√≠o con if(!heapObjects.empty()).

Luego se accede al √∫ltimo puntero, se libera con delete.

Finalmente se borra la referencia del vector con pop_back.

Esto es fundamental porque:

Si se elimina el puntero del vector sin hacer delete, el objeto sigue en memoria (fuga).

Si se hace delete pero no pop_back, el vector tendr√≠a punteros colgantes (dangling pointers).

RETO
