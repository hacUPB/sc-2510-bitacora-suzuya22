## Que son los vertices?

los vertices son puntos en el espacio 3D que estan determinados por coordenadas y definen la forma de los objetos graficos, cada uno de estos vertices poseen atributos como posicion,
color y coordenadas de textura

## Con que figura geometrica se dibuja en 3D?
La figura geometrica con la que se dibuja en 3D es el triangulo, esto debido a que es la figura geometrica mas basica con la cual se puede definir una superficie en el espacio tridimensional

## Que es un shader?
Un shader es un programa que se ejecuta en la GPU, este programa esta encargado de administrar como se procesan los vertices y los fragmentos (pixeles) durante el renderizado, se usa el lenguaje GLSL para escribirlo

## Como se llaman los grupos de pixeles de un solo triangulo?
a estos grupos de pixeles se les llama "fragmentos", cada fragmento representa una contribucion a un pixel en la pantalla y contiene informacion como el color y la profundidad (controlado por el Depht), estos fragmentos se generan en el momento de la renderizacion

## Que es el fragment shader?
Es un tipo de shader que se ejecuta para cada fragmento y esta encargado de determinar el color final de cada pixel en pantalla, aplicando los efectos de iluminacion, texturizado y la transparencia

## Que es el vertex shader?
Es un tipo de shader que se ejecuta para cada vertices y se encarga de guardar la informacion de posicion final del vertice, tambien puede generar otros valores como colores o coordenadas de textura

## ¬øAl proceso de determinar qu√© p√≠xeles del display va a cubrir cada tri√°ngulo de una mesh se le llama?
Este proceso se llama "rasterizaci√≥n". Durante la rasterizaci√≥n, se determinan los fragmentos que corresponden a cada tri√°ngulo y se interpolan los valores necesarios para cada fragmento.


## ¬øQu√© es el render pipeline?
El render pipeline es la secuencia de pasos que sigue la GPU para convertir los datos de una escena 3D en una imagen 2D en la pantalla. Incluye etapas como la transformaci√≥n de v√©rtices, ensamblado de primitivas, rasterizaci√≥n, ejecuci√≥n de shaders y operaciones finales de p√≠xel.

## ¬øHay alguna diferencia entre aplicar un color a una superficie de una mesh o aplicar una textura?
S√≠, hay una diferencia. Aplicar un color significa asignar un valor de color uniforme o por v√©rtice a la superficie. Aplicar una textura implica mapear una imagen sobre la superficie, lo que permite detalles m√°s complejos y variados.

## ¬øCu√°l es la diferencia entre una textura y un material?
Una textura es una imagen que se aplica a la superficie de un objeto para darle detalle visual. Un material es una colecci√≥n de propiedades que define c√≥mo la superficie de un objeto interact√∫a con la luz, incluyendo texturas, colores, reflectividad y otros par√°metros.

## ¬øQu√© transformaciones se requieren para mover un v√©rtice del 3D world al View Screen?
Se requieren varias transformaciones:

Transformaci√≥n del modelo: posiciona el objeto en el mundo.

Transformaci√≥n de vista: posiciona y orienta la c√°mara.
sistemascomputacionales.readthedocs.io

Transformaci√≥n de proyecci√≥n: convierte las coordenadas 3D en coordenadas 2D de pantalla.

Estas transformaciones se combinan en una matriz que se aplica a cada v√©rtice en el vertex shader.

## ¬øAl proceso de convertir los tri√°ngulos en fragmentos se le llama?
Este proceso tambi√©n se llama "rasterizaci√≥n". Es la etapa en la que se determinan los fragmentos que corresponden a cada tri√°ngulo para su posterior procesamiento en el fragment shader.

## ¬øQu√© es el framebuffer?
El framebuffer es una memoria en la GPU que almacena la imagen final que se mostrar√° en la pantalla. Contiene informaci√≥n de color, profundidad y otros datos necesarios para componer la imagen final.

## ¬øPara qu√© se usa el Z-buffer o depth buffer en el render pipeline?
El Z-buffer, o depth buffer, se utiliza para almacenar la informaci√≥n de profundidad de cada p√≠xel. Permite determinar qu√© objetos est√°n delante de otros y asegurar que los objetos m√°s cercanos a la c√°mara oculten a los que est√°n detr√°s.

#Actividad #2

Comienza realizando la lectura de la introducci√≥n del tutorial¬†[Introducing Shaders](https://openframeworks.cc/ofBook/chapters/shaders.html). Realiza la secci√≥n Your First Shader, pero antes de ejecutar el c√≥digo, realiza un peque√±o experimento. Modifica ligeramente el m√©todo draw:

```cpp
void ofApp::draw(){
    ofSetColor(255);

    //shader.begin();

    ofDrawRectangle(0, 0, ofGetWidth(), ofGetHeight());

    //shader.end();
}
```

Observa la salida.

### salida
Con esta salida solo aparece un rectangulo blanco debido al setcolor(255), esto debido a que al comentar el shader begin y el shader end no estas accediendo directamente a ellos, solo estas dibujando un cuadrado blanco

"ofDrawRectangle(0, 0, ofGetWidth(), ofGetHeight());"

## ¬øQu√© resultados obtuviste?
Resultado esperado: El rect√°ngulo muestra un degradado de color. El color var√≠a dependiendo de la posici√≥n en pantalla (m√°s rojo a la derecha, m√°s verde hacia arriba).
En la pr√°ctica: Al principio no se ve√≠a correctamente, pero despu√©s de ubicar bien los archivos shader.vert y shader.frag en la carpeta bin/data/shadersGL3/, funcion√≥.

## ¬øC√≥mo funciona?
El shader se aplica a los fragmentos (pixeles) que forman el rect√°ngulo. Se calcula el color en tiempo real en el fragment shader, usando las coordenadas de cada fragmento.

## ¬øEst√°s usando un vertex shader?
S√≠. El archivo shader.vert act√∫a como vertex shader. Su funci√≥n es transformar la posici√≥n de los v√©rtices mediante una matriz (modelViewProjectionMatrix), algo esencial para que los objetos se muestren correctamente en la pantalla.

## ¬øEst√°s usando un fragment shader?
S√≠. El archivo shader.frag act√∫a como fragment shader. Es el que define el color final de cada p√≠xel del rect√°ngulo, utilizando las coordenadas gl_FragCoord.x y gl_FragCoord.y para calcular los valores rojo y verde.

## Analasis de los codigos de los shader

### vertex shader
``` cpp
#version 150

uniform mat4 modelViewProjectionMatrix;
in vec4 position;

void main(){
    gl_Position = modelViewProjectionMatrix * position;
}
```

este codigo lo que esta haciendo es que por medio de una matriz de transformacion esta controlando y transformando cada vertice del rectangulo que creamos, lo que hace en es transformar esos vertices en coordenadas de pantalla

 ### fragment shader

  ``` cpp
  #version 150

out vec4 outputColor;

void main()
{
    float windowWidth = 1024.0;
    float windowHeight = 768.0;

    float r = gl_FragCoord.x / windowWidth;
    float g = gl_FragCoord.y / windowHeight;
    float b = 1.0;
    float a = 1.0;
    outputColor = vec4(r, g, b, a);
}
```
el fragment shader lo que esta haciendo es que para cada fragmento (pixel) estan controlando el color que va a mostrar dependiendo de su posicion en la pantalla usando el rgb para esto

   float r = gl_FragCoord.x / windowWidth;

   con esto entendemos que el el valor r del rgb depende de la posicion horizontal del cuadro, tambien vemos que g depende del vertical y "b" tiene un valor constante de 1.0

  ## Conclusi√≥n
El experimento muestra la diferencia clara entre usar y no usar shaders. Cuando los shaders est√°n activos, se puede personalizar completamente la forma en que se dibuja cada p√≠xel. Este ejemplo sirve como una excelente introducci√≥n al potencial de los shaders en gr√°ficos computacionales.

¬øQuieres que te d√© un ejemplo m√°s interactivo con movimiento o textura?

## Actividad 3

siguiendo los pasos de la seccion "Adding Uniforms" hemos creado una malla que utiliza un uniform que controla el tiempo para animar la geometria de la malla creada (el efecto agua)
mueve los vertices en el shader en base a tiempo basicamente, y usando  ofSetColor() para que OpenFrameworks pase autom√°ticamente ese color al shader como uniform vec4 globalColor.

time es un n√∫mero que aumenta constantemente con cada frame.

Usando sin(time + algo), creas un movimiento ondulante que cambia en el tiempo.

Al multiplicar por displacementHeight, haces que los v√©rtices suban y bajen como una ola.

### ¬øque es un uniform?

un uniform es una variable global en el shader que no cambia por v√©rtice o por p√≠xel, sino por draw call.

Es una forma de enviar datos desde tu app en C++ hacia el shader.

Ejemplos comunes:

Tiempo (time)

Color global (globalColor)

Matrices (modelViewProjectionMatrix)

## ¬øC√≥mo funciona el c√≥digo de aplicaci√≥n, los shaders y c√≥mo se comunican estos?

El codigo de la aplicacion funciona con el archivo cpp controlando lo que van a hacer los shaders mediante el control de la variable uniform global que tienen estos, se comunican de esta forma con un call draw
 shader.setUniform1f("time", ofGetElapsedTimef());
 con esto desde el offApp.cpp se controla la variable del uniform para definir lo que se va a hacer en el shader, NO cambia en tiempo de ejecucion, solo se actualiza cada frame
    

 ## Actividad 4

 ### ¬øQu√© hace el c√≥digo del ejemplo?

 El codigo del ejemplo hace que se cree la malla del ejemplo anterior el cual se controla el color entre magenta y azul mediante la posicion del mouse, solo que ahora se elimino el uniform del tiempo para la animacion de esta y se a√±adio un uniform de

  shader.setUniform1f("mouseRange", 150); // SET A UNIFORM

  y

   shader.setUniform2f("mousePos", mx, my);  // SET A UNIFORM


   para controlar mediante el programa la distorsion de los vertices haciendo un efecto donde esta el mouse


 ### ¬øC√≥mo funciona el c√≥digo de aplicaci√≥n, los shaders y c√≥mo se comunican?
 ### ofApp.cpp (c√≥digo de aplicaci√≥n)
Calcula la posici√≥n del mouse respecto al centro de la pantalla.

Usa funciones como setUniform1f, setUniform2f y setUniform4fv para enviar datos al shader:

mouseRange: un flotante que define el radio de influencia del mouse.

mousePos: un vec2 con la posici√≥n relativa del mouse.

mouseColor: un vec4 que mezcla colores seg√∫n la posici√≥n del mouse.

 ### Vertex Shader
Recibe la posici√≥n de cada v√©rtice.

Calcula la distancia desde cada v√©rtice hasta el mouse.

Si el v√©rtice est√° dentro del rango (mouseRange), lo aleja del mouse en proporci√≥n inversa a la distancia.

Esta nueva posici√≥n se multiplica por modelViewProjectionMatrix para ser renderizada.

 ### Fragment Shader
Pinta cada p√≠xel del plano con el color que viene desde el uniforme mouseColor, calculado en C++.

üîÅ Comunicaci√≥n
Se realiza mediante uniforms, que permiten pasar datos desde el CPU (C++) al GPU (shader) una vez por frame.

## Modificacion

Modificaci√≥n en Vertex Shader
Podemos cambiar la direcci√≥n del efecto para que los v√©rtices se acerquen al mouse (atracci√≥n en vez de repulsi√≥n):
``` cpp
// En lugar de alejarse del mouse
pos.x -= dir.x;
pos.y -= dir.y;
```

## Modificaci√≥n en Fragment Shader

Agrega una variaci√≥n de color basada en la posici√≥n de fragmento:


#version 150

out vec4 outputColor;
uniform vec4 mouseColor;

void main()
{
    // Usa el color original pero haz que el rojo dependa de la coordenada y.
    outputColor = vec4(mouseColor.r * gl_FragCoord.y / 800.0, mouseColor.g, mouseColor.b, 1.0);
}

# RETO

RAE1

para la construccion de esta aplicacion lo que primero hice fue pensar que era lo que queria controlar con los shaders y la app, pense en un crear una malla como las anteriores pero dandole un efecto de rotacion y cambio de color en base a la posicion del mouse, para esto debia identificar como crear la variable de rotacion que controlaria despues en la app con los uniforms, para esto busque en internet y me ayude con ia para entender como se controlaba esta parte


  
    float angle = time * rotationSpeed * 5.0; 

  
    float x = pos.x * cos(angle) - pos.y * sin(angle);
    float y = pos.x * sin(angle) + pos.y * cos(angle);
    pos.x = x;
    pos.y = y;

    gl_Position = modelViewProjectionMatrix * pos;

lo que se esta haciendo desde el vertex es mediante el time calcular la velocidad de rotacion y haciendose una multiplicacion para que sea mas visible, luego se controla la posicion de los vertices para rotarlos en el eje Z (Esta parte fue la que mas ayuda de ia necesite, queria definir bien como era la operacion matematica para calcular esta rotacion de angulo)



Para la parte del fragment shader fue m√°s sencillo, solo cre√© las variables de color r√°pido y lento y les asign√© los valores correctos de RGB.

El color lento lo puse blanco (1.0, 1.0, 1.0) y el color r√°pido lo puse rojo (1.0, 0.0, 0.0). Luego us√© la funci√≥n mix() para mezclar esos dos colores seg√∫n el valor de rotationSpeed.

As√≠, cuando la velocidad es baja, el color se acerca al blanco, y cuando la velocidad es alta, se acerca al rojo. Esto hace que el color de la malla cambie visualmente dependiendo de qu√© tan r√°pido est√© rotando.

## codigo fuente

### .cpp

```cpp
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofBackground(0);
    plane.set(400, 400, 40, 40);
    plane.mapTexCoordsFromTexture(ofTexture());

    shader.load("shadersGL3/shader");
}

//--------------------------------------------------------------
void ofApp::update() { }

//--------------------------------------------------------------
void ofApp::draw() {
    shader.begin();

   
    float percentX = mouseX / float(ofGetWidth());
    percentX = ofClamp(percentX, 0.0, 1.0);

    shader.setUniform1f("rotationSpeed", percentX); 
    shader.setUniform1f("time", ofGetElapsedTimef());

    ofPushMatrix();
    ofTranslate(ofGetWidth() / 2, ofGetHeight() / 2);
    plane.drawWireframe();
    ofPopMatrix();

    shader.end();
}
```

### vertex

```cpp
#version 150

uniform mat4 modelViewProjectionMatrix;
uniform float time;
uniform float rotationSpeed;

in vec4 position;

void main(){
    vec4 pos = position;

  
    float angle = time * rotationSpeed * 5.0; 


    float x = pos.x * cos(angle) - pos.y * sin(angle);
    float y = pos.x * sin(angle) + pos.y * cos(angle);
    pos.x = x;
    pos.y = y;

    gl_Position = modelViewProjectionMatrix * pos;
}
```

### Fragment
```cpp

#version 150

out vec4 outputColor;
uniform float rotationSpeed;

void main(){
   
    vec3 slowColor = vec3(1.0);            
    vec3 fastColor = vec3(1.0, 0.0, 0.0);  
    vec3 color = mix(slowColor, fastColor, rotationSpeed);
    outputColor = vec4(color, 1.0);
}

```

### Explica y muestra c√≥mo probaste la aplicaci√≥n en ofApp.cpp:

Para probar la aplicaci√≥n en ofApp.cpp, primero me asegur√© de inicializar correctamente la malla con plane.set(...) y de cargar el shader con shader.load(...). Luego, dentro del m√©todo update(), calcul√© la velocidad de rotaci√≥n (rotationSpeed) mapeando la posici√≥n horizontal del mouse a un valor entre 0.0 y 1.0 usando ofMap(). Esta variable se pas√≥ al shader como un uniform usando shader.setUniform1f("rotationSpeed", rotationSpeed);.

Para observar el efecto, ejecut√© la aplicaci√≥n y mov√≠ el mouse de izquierda a derecha en la ventana. Verifiqu√© que la malla giraba m√°s r√°pido hacia la derecha y m√°s lento hacia la izquierda, como se esperaba.

### Explica y muestra c√≥mo probaste el vertex shader:

En el vertex shader, prob√© el comportamiento manipulando directamente las posiciones de los v√©rtices. Us√© una matriz de rotaci√≥n en 2D para girar los v√©rtices en el plano XY. La velocidad de rotaci√≥n depend√≠a del valor del uniform float rotationSpeed recibido desde la aplicaci√≥n. Us√© funciones trigonom√©tricas (cos y sin) para construir la matriz de rotaci√≥n y aplicar la transformaci√≥n a cada v√©rtice.

Para probarlo, ejecut√© la aplicaci√≥n y confirm√© que la malla rotaba m√°s lentamente cuando el mouse estaba a la izquierda de la ventana, y m√°s r√°pidamente cuando el mouse se mov√≠a hacia la derecha.

### Explica y muestra c√≥mo probaste el fragment shader:

Para la parte del fragment shader fue m√°s sencillo. Solo cre√© las variables de color r√°pido y lento y les asign√© los valores correctos de RGB. El color lento lo puse blanco (1.0, 1.0, 1.0) y el color r√°pido lo puse rojo (1.0, 0.0, 0.0). Luego us√© la funci√≥n mix() para mezclar esos dos colores seg√∫n el valor de rotationSpeed.

Prob√© este shader ejecutando la aplicaci√≥n y observando los cambios de color. Al mover el mouse a la izquierda, los fragmentos de la malla se mostraban en color blanco; al moverlo a la derecha, el color cambiaba progresivamente hasta llegar al rojo, lo cual confirm√≥ que el shader estaba funcionando correctamente.

### Explica y muestra c√≥mo probaste toda la aplicaci√≥n completa:

Finalmente, para probar toda la aplicaci√≥n completa, corr√≠ el programa en OpenFrameworks y observ√© que la malla reaccionaba correctamente tanto en movimiento como en color. La rotaci√≥n de la malla respond√≠a en tiempo real a la posici√≥n del mouse en el eje X, y el color de los fragmentos cambiaba de blanco a rojo seg√∫n esa misma velocidad.

Verifiqu√© que no aparecieran errores en consola y que la respuesta visual fuera fluida y coherente con lo esperado. Esta prueba me permiti√≥ confirmar que tanto el c√≥digo en ofApp.cpp como los shaders estaban funcionando en conjunto de forma correcta y sin conflictos.

### link:

https://youtu.be/QGw8kWIO6tY